#!/usr/bin/env bash

for ARGUMENT in "$@"; do
    [[ "$ARGUMENT" == "--mine" ]] && MINE=1

    KEY=$( echo $ARGUMENT | cut -f1 -d= )
    VALUE=$( echo $ARGUMENT | cut -f2 -d= )

    case "$KEY" in
        --days) DAYS=$((${VALUE} + 1)) ;;
        *) ;;
    esac
done

# generate datetime str set to the first minute (00:00) / 12:00 AM
date_fmt='+%FT00:00%z'
midnight=$( date $date_fmt )
days_ago=$( date -v-${DAYS}d $date_fmt )

# update the repository, silently
git_up > /dev/null 2>&1

# gather range of commit hashes between N+1 days ago and midnight
hashes=$( git log --no-merges --format="%H" --since=${days_ago} --until=${midnight} )

# if no hashes, exit without printing anything
[[ -z "$hashes" ]] && exit 0

oldest_hash=$( echo "$hashes" | tail -n 1 )
newest_hash=$( echo "$hashes" | head -n 1 )

if [[ $MINE -eq 1 ]]; then
    email=$( git config --get user.email )
    # if --mine passed, only get logs I myself committed
    recap_by_range "$oldest_hash" "$newest_hash" | grep $email
else
    recap_by_range "$oldest_hash" "$newest_hash"
fi

